更多的关于正则表达式的参考可见：
'''
https://c.runoob.com/front-end/854/
https://tool.oschina.net/regex#    
https://goregex.cn/
'''
    
# 正则表达式的7个境界
import re

# 1 固定的字符串: 确定字符串中是否有123
text = '我有123个大苹果'
print(re.findall(r'123', text))

# 2 某一类字符：找出所有的单个的数字
text = '我有123个大苹果'
print(re.findall(r'\d', text))

# 3 重复某一类字符：找所有的数字
text = '我有123个大苹果，他有250个大西瓜'
print(re.findall(r'\d+', text))

# 4 组合level 2: 找出座机号码
text = '我的电话号码是0571-52152166，他的手机号是18438605789'
print(re.findall(r'\d{4}-\d{8}', text)) 

# 5 多种情况：找出手机号码和座机号码
text = '我的电话号码是0571-52152166，他的手机号是18438605789'
print(re.findall(r'\d{4}-\d{8}|1\d{10}', text))

# 6 限定位置：找出在句子开头的手机号码或座机号码
text = '18438605789,我的电话号码是0571-52152166，他的手机号是18438605789'
print(re.findall(r'^1\d{10}|^\d{4}-\d{8}', text))

# 7 内部约束：找出形如 barbar,dardar之类的重复字符串
text = 'barbar carbus harhel'
print(re.findall(r'(\w{3})(\1)', text))


'''
写正则表达式的套路：以包含分机号码的座机电话号码为例 0571-88776655-9527
1 确定模式包含几个子模式：
    包含3个子模式，这3个子模式用固定字符连接
    
2 各个部分的字符分类是什么
    这3个子模式都是数字类型，可以用\d，现在可以写出 \d-\d-\d
    
3 各个部分如何重复
    但是d只表示一个数字，因此需要考虑数字要重复几次。根据座机号码的特点：
    第一个子模式的数字重复3-4次，第二个子模式的数字重复7-8次，第三个子模式的数字重复3-4次
    现在可以写为 \d{3,4}-\d{7,8}-\d{3,4}
    但有的座机没有分机号
    再优化为 \d{3,4}-\d{7,8}-\d{3,4}|\d{3,4}-\d{7,8}
    
4 是否有外部位置限制
    没有

5 是否有内部制约关系
    没有
    
最后为 re.findall(r'\d{3,4}-\d{7,8}-\d{3,4}|\d{3,4}-\d{7,8}', text)
'''


'''
正则表达式的语法规则：这里只记录常用的，更多的参考：
-----------
1 字符的类别：
-----------
\d  一个数字
\D  一个非数字字符
\s  一个空格
\S  一个非空格
[abcf]  a,b,c,f中的任意一个字符
[a-e]  从a到e的任意一个字符，也可以是[1-9]
[^a-d]  除了a,b,c,d之外的任意一个字符
.  通配符，除了换行\n之外的任意一个字符

---------------
2 字符的重复次数（量词）
---------------
*  0或多个
+  1或多个
?  0或1个
{2}  2个
{2,5}  2-5个
{2,}  至少2个
{,5}  最多5个

-------------
3 组合模式：把多个简单的模式组合在一起，可以是拼接，也可以是二者选其一
-------------
\d{6}[a-z]{6}  多个简单模式直接前后组合在一起。前面的表示：六个数字和六个小写字母的组合形式
|  或
()  分组，分组后可以以组为单位应用量词。(abc){3}表示abcabcabc

------------
4 位置
------------
^  字符串开头
\A  字符串开头，忽略m标记
$  字符串行尾
\Z  字符串行尾，忽略m标记
\b  单词边界
\B  非单词边界
(?=...)  匹配...出现在之后的位置
(?!...)  匹配...不出现在之后的位置
(?<=...)  匹配...出现在之前的位置
(?<!...)  匹配...不出现在之前的位置
(?()|)  条件语句

举例：在 “学号：123456，密码：666” 找到出现在 密码 后的内容
text = '学号：123456，密码：666'
re.findall(r'(?<=密码.)\d+', text) #.在这里表示任何字符

------------
5 分组
------------
(...)  捕获一个组
(?P<Y>...)  捕获组名为Y
(?:...)  不捕获组
\Y  匹配第Y个匹配到的组
(?P=Y)  匹配名为Y的组
(?#...)  注释
 
-----------
 6 其他
-----------
 i  忽略大小写: 在re中使用方法： re.findall(r'模式', text, flags=re.I)
 m  ^和$匹配行首和行尾
 s  .匹配换行符
 x  允许空格和注释
 \L  由当前语言区域觉得 \w, \W, \b, \B 和大小写敏感匹配
 \u  Unicode匹配
 (?iLmsux)  在正则表达式中设置标记
 
 ---------
 7 特殊字符
 ---------
 \n  换行符
 \r  回车符
 \t  tab符号
 \YYY  八进制符号YYY
 \xYY  16进制符号YY
 
 ---------
 8 替换
 ---------
 \g<0>  插入整段匹配
 \g<Y>  插入匹配Y，Y可以是匹配的名字或指数字
 \Y  插入名为Y的组
 '''
 
 
 '''
re的用法：

re.search  查找符合模式的字符，只返回第一个，返回match对象
re.match  和search一样，但要求必须从字符串开头匹配
re.findall  返回所有匹配的字符串列表
re.finditer  返回一个迭代器，其中包含所有的匹配，也就是match对象
re.sub  替换匹配的字符串，返回替换完成的文本
re.subn  替换匹配的字符串，返回替换完成的文本和替换的次数
re.split  用匹配表达式的字符串做分隔符分割原字符串
re.compile  把正则表达式编译成一个对象，方便后面使用
'''
 
